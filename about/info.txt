// 08.02.2023	Знакомство с JavaScript
Полезный ресурс: https://learn.javascript.ru/
Установка node.js.
Установка Visual Studio Code.
Справочники и спецификации: https://learn.javascript.ru/manuals-specifications
Страница для тестов браузера: https://learn.javascript.ru/article/devtools/bug.html
*Установить расширение Live Server в Visual Studio Code и отключить на первое время.

// 08.02.2023	Работа с браузером и консолью.
F12 (Windows) - открытие консоли в браузере.
Enter - ввод данных в консоль.
Shift + Enter - переход на другую строку.
Программы на JavaScript могут быть вставлены в любое место HTML-документа с помощью тега <script>
	<script>
    	alert('Привет, мир!');
  	</script>

// 08.02.2023	Разметки (Признаки старого кода)
Атрибут type: <script type=…> - Старый стандарт HTML, HTML4, требовал наличия этого атрибута в теге <script>
Атрибут language: <script language=…> - атрибут должен был задавать язык, на котором написан скрипт.
Скрытие скрипта в HTML-комментарии: <script type="text/javascript"><!--...//--></script>

// 08.02.2023	Пути хранения скрипта
Здесь /path/to/script.js – это абсолютный путь до скрипта от корня сайта. 
Также можно указать относительный путь от текущей страницы: src="script.js" или src="./script.js" будет означать, что файл "script.js" находится в текущей папке. В одном теге <script> нельзя использовать одновременно атрибут src и код внутри.

// 09.02.2023	Структура кода
Обычно каждую инструкцию пишут на новой строке, чтобы код было легче читать, рекомендуется ставить всегда символ ";":
 	alert('Привет');
	alert('Мир');
Ошибки, которые при этом появляются (если не ставить ;), достаточно сложно обнаруживать и исправлять.
Инструкцию можно написать и в одну строку, но не рекомендуется: alert('Привет'); alert('Мир');
В большинстве случаев новая строка подразумевает точку с запятой. Но «в большинстве случаев» не значит «всегда»:
	alert(3 +
	1
	+ 2);

// 09.02.2023	Комментарии
Однострочные: //
Многострочные: /* ... */
Ctrl + / - выбор нужной строки и ее мгновенное комментирование.
Вложенные комментарии не поддерживаются!

// 09.02.2023   В .js файле, в самом верху можно прописать // @ts-check , в компиляторе будет подсвечиваться различные несоответсвия логики.

// 09.02.2023	Строгий режим — "use strict"
Если требуется запуск приложения, где используется устаревший синтаксис, в первую строчку мы вписываем: "use strict";
Еще его можно подключать к конкретной функции. После подключения, его уже невозможно отменить. Над "use strict" могут быть записаны только комментарии. В дальнейшем, когда вы будете использовать консоль браузера для тестирования функций, обратите внимание, что use strict по умолчанию в ней выключен. По умолчанию, всегда рекомендуется указывать "use strict" в начале документа/работы в консоли.

// 09.02.2023	Для объявления переменной в JavaScript используйте ключевое слово let.
	let message = 'Hello';
	alert(message);
Имя переменной должно содержать только буквы, цифры или символы $ и _.
Правило/Стиль написания переменной: camelCase.

// 09.02.2023	Константы
Объявление и инициализация константы: const myBirthday = '18.04.1982';
Широко распространена практика использования констант в качестве псевдонимов для трудно запоминаемых значений, которые известны до начала исполнения скрипта. Названия таких констант пишутся с использованием заглавных букв и подчёркивания.
Пример: const COLOR_RED = "#F00";

// 10.02.2023	Типы данных
Есть восемь основных типов данных в JavaScript: number, bigint, string, boolean, null, undefined, symbol, object. Переменная в JavaScript может содержать любые данные. В один момент там может быть строка, а в другой – число. Языки программирования, в которых такое возможно, называются «динамически типизированными».

// 10.02.2023	Числа			
Кроме обычных чисел, существуют так называемые «специальные числовые значения», которые относятся к этому типу данных: Infinity, -Infinity и NaN.
Infinity представляет собой математическую бесконечность ∞. Это особое значение, которое больше любого числа. Мы можем получить его в результате деления на ноль или задать явно: alert( 1 / 0 ); alert( Infinity ); 
NaN означает вычислительную ошибку. Это результат неправильной или неопределённой математической операции. Если где-то в математическом выражении есть NaN, то оно распространяется на весь результат.
Есть только одно исключение: NaN ** 0 равно 1. Скрипт никогда не остановится с фатальной ошибкой (не «умрёт»). В худшем случае мы получим NaN как результат выполнения. Тип BigInt был добавлен в JavaScript, чтобы дать возможность работать с целыми числами произвольной длины: 
const bigInt = 1234567890123456789012345678901234567890n;

// 10.02.2023	В JavaScript существует три типа кавычек: "Привет", 'Привет', `Привет` и интерполяция ${...}.
Двойные или одинарные кавычки являются «простыми», между ними нет разницы в JavaScript. Обратные же кавычки имеют расширенную функциональность. Они позволяют нам встраивать выражения в строку, заключая их в ${…}. Например: alert( `результат: ${1 + 2}` );

// 10.02.2023	Булевый (логический) тип
	let nameFieldChecked = true;
Булевые значения также могут быть результатом сравнений: let isGreater = 4 > 1; alert( isGreater );

// 10.02.2023	Значение «null» и «undefined»
В JavaScript null не является «ссылкой на несуществующий объект» или «нулевым указателем», как в некоторых других языках. Это просто специальное значение, которое представляет собой «ничего», «пусто» или «значение неизвестно». null является объектом: let age = null;
Значение «undefined» означает, что «значение не было присвоено». Обычно null используется для присвоения переменной «пустого» или «неизвестного» значения, а undefined – для проверок, была ли переменная иниацилизированна.

// 10.02.2023	Объекты и символы
object -  в объектах же хранят коллекции данных или более сложные структуры.
symbol - используется для создания уникальных идентификаторов в объектах.

// 10.02.2023	Оператор typeof
Оператор typeof возвращает тип аргумента - позволяет узнать тип данных. Это полезно, когда мы хотим обрабатывать значения различных типов по-разному или просто хотим сделать проверку. У него есть две синтаксические формы: синтаксис оператора: typeof x и синтаксис функции: typeof(x). Он работает со скобками или без скобок. Результат одинаковый.

// 10.02.2023	Взаимодействие: alert, prompt, confirm

alert - небольшое окно с сообщением называется модальным окном. Понятие модальное означает, что пользователь не может взаимодействовать с интерфейсом остальной части страницы, нажимать на другие кнопки и т.д. до тех пор, пока взаимодействует с окном.

prompt - функция prompt принимает до двух аргументов. Этот код отобразит модальное окно с текстом, полем для ввода текста и кнопками OK/Отмена.
Пример: let result = prompt('ЗАГОЛОВОК', 'ТЕКСТ ВНУТРИ ФОРМЫ ВВОДА');

confirm - Функция confirm отображает модальное окно с текстом вопроса question и двумя кнопками: OK и Отмена / True и False.
Пример: result = confirm(question);

// 12.02.2023	Преобразование типов (Явные преобразования)
Строковое преобразование
Пример: String(value) - вызываем класс String.

Численное преобразование (неявное преобразование)
Пример: alert( "6" / "2" ); // 3, строки преобразуются в числа.
	let num = Number(str); - переменная становится числом 123.

	undefined - NaN
	null - 0
	true / false - 1 / 0
	
string:	пробельные символы (пробелы, знаки табуляции \t, знаки новой строки \n и т. п.) по краям обрезаются. Далее, если остаётся пустая строка, то получаем 0, иначе из непустой строки «считывается» число. При ошибке результат NaN.

	alert( Number("   123   ") ); // 123
	alert( Number("123z") );      // NaN (ошибка чтения числа на месте символа "z")
	alert( Number(true) );        // 1
	alert( Number(false) );       // 0
	Учтите, что null и undefined ведут себя по-разному. Так, null становится нулём, тогда как undefined приводится к NaN.

// 12.02.2023	Логическое преобразование
Значения, которые интуитивно «пустые», вроде 0, пустой строки, null, undefined, "" и NaN, становятся false. Все остальные значения становятся true. Некоторые языки (к примеру, PHP) воспринимают строку "0" как false. Но в JavaScript, если строка не пустая, то она всегда true.

// 12.02.2023	Базовые операторы и математика
Термины: «унарный», «бинарный», «операнд».
Операнд – то, к чему применяется оператор.
Унарным называется оператор, который применяется к одному операнду: -x
Бинарным называется оператор, который применяется к двум операндам: alert( y + x );

Сложение + | Складывание строк - конкатенация.
Вычитание -
Умножение *
Деление /
Результат остатка от деления %
Возведение в степень **

При сложении, если хотя бы один операнд является строкой, то второй будет также преобразован в строку. Другие арифметические операторы работают только с числами и всегда преобразуют операнды в числа.
Пример: alert( 6 - '2' ); // 4, '2' приводится к числу.

// 12.02.2023	Сокращённая арифметика с присваиванием: n = n + 5; n += 5; n *= 3 + 5;

// 12.02.2023	Инкремент/декремент (Постфиксный и префиксный): a++ и ++a;
Префиксная форма возвращает новое значение, в то время как постфиксная форма возвращает старое (до увеличения/уменьшения числа).

// 12.02.2023	Побитовые операторы
AND(и) ( & )
OR(или) ( | )
XOR(побитовое исключающее или) ( ^ )
NOT(не) ( ~ )
LEFT SHIFT(левый сдвиг) ( << )
RIGHT SHIFT(правый сдвиг) ( >> )
ZERO-FILL RIGHT SHIFT(правый сдвиг с заполнением нулями) ( >>> )
Они используются редко, когда возникает необходимость оперировать с числами на очень низком (побитовом) уровне. 

Оператор «запятая»
Оператор «запятая» предоставляет нам возможность вычислять несколько выражений, разделяя их запятой ,. Каждое выражение выполняется, но возвращается результат только последнего.
	let a = (1 + 2, 3 + 4);
	alert( a ); // 7 (результат вычисления 3 + 4)

// 12.02.2023	Операторы сравнения
Больше/меньше: a > b, a < b, Равенство: a == b, a != b
Все операторы сравнения возвращают значение логического типа: true, false.

Сравнение строк
	alert( 'Я' > 'А' ); // true
	alert( 'Коты' > 'Кода' ); // true
	alert( 'Сонный' > 'Сон' ); // true
Заглавная буква "A" не равна строчной "a". Какая же из них больше? Строчная "a". Почему? Потому что строчные буквы имеют больший код во внутренней таблице кодирования, которую использует JavaScript (Unicode).

Сравнение разных типов
При сравнении значений разных типов JavaScript приводит каждое из них к числу.
	alert( '2' > 1 ); // true, строка '2' становится числом 2
	alert( '01' == 1 ); // true, строка '01' становится числом 1

Логическое значение true становится 1, а false – 0.
	let a = 0;
	alert( Boolean(a) ); // false
	let b = "0";
	alert( Boolean(b) ); // true
	alert(a == b); // true!

Строгое сравнение
Использование обычного сравнения == может вызывать проблемы. Например, оно не отличает 0 от false:
	alert( 0 == false ); // true
	alert( '' == false ); // true
Оператор строгого равенства === проверяет равенство без приведения типов.

Ещё есть оператор строгого неравенства !==, аналогичный !=.

Странный результат сравнения null и 0.
	alert( null > 0 );  // (1) false
	alert( null == 0 ); // (2) false
	alert( null >= 0 ); // (3) true

С точки зрения математики это странно. Результат последнего сравнения говорит о том, что "null больше или равно нулю", тогда результат одного из сравнений выше должен быть true, но они оба ложны. Причина в том, что нестрогое равенство и сравнения > < >= <= работают по-разному. Сравнения преобразуют null в число, рассматривая его как 0. Поэтому выражение (3) null >= 0 истинно, а null > 0 ложно. С другой стороны, для нестрогого равенства == значений undefined и null действует особое правило: эти значения ни к чему не приводятся, они равны друг другу и не равны ничему другому. Поэтому (2) null == 0 ложно.
				
Несравненное значение undefined
	alert( undefined > 0 ); // false (1)
	alert( undefined < 0 ); // false (2)
	alert( undefined == 0 ); // false (3)

Почему же сравнение undefined с нулём всегда ложно?
На это есть следующие причины:
Сравнения (1) и (2) возвращают false, потому что undefined преобразуется в NaN, а NaN – это специальное числовое значение, которое возвращает false при любых сравнениях. Нестрогое равенство (3) возвращает false, потому что undefined равно только null, undefined и ничему больше.

Как избежать проблем
Зачем мы рассмотрели все эти примеры? Должны ли мы постоянно помнить обо всех этих особенностях? Не обязательно. Со временем все они станут вам знакомы, но можно избежать проблем, если следовать надёжным правилам:

Относитесь очень осторожно к любому сравнению с undefined/null, кроме случаев строгого равенства ===. Не используйте сравнения >= > < <= с переменными, которые могут принимать значения null/undefined, разве что вы полностью уверены в том, что делаете. Если переменная может принимать эти значения, то добавьте для них отдельные проверки.

// 12.02.2023	Условное ветвление
Инструкция «if» - Инструкция if(...) вычисляет условие в скобках и, если результат true, то выполняет блок кода.
	let year = prompt('В каком году была опубликована спецификация ECMAScript-2015?', ''); {
	if (year == 2015); alert( 'Вы правы!' );
	}

Если мы хотим выполнить более одной инструкции, то нужно заключить блок кода в фигурные скобки, как на примере выше. На примере выше, инструкция всего одна, в таком случае использование фигурных скобок необязательно.

Блок «else»
Инструкция if может содержать необязательный блок «else» («иначе»). Он выполняется, когда условие ложно.
	let year = prompt('В каком году была опубликована спецификация ECMAScript-2015?', '');
Пример:
	if (year == 2015) {
  	alert( 'Да вы знаток!' );
	} else {
  	alert( 'А вот и неправильно!' ); // любое значение, кроме 2015
	}

// 13.02.2023	Несколько условий: «else if»
Иногда нужно проверить несколько вариантов условия. Для этого используется блок else if.
	let year = prompt('В каком году была опубликована спецификация ECMAScript-2015?', '');

	if (year < 2015) {
  	alert( 'Это слишком рано...' );
	} else if (year > 2015) {
  	alert( 'Это поздновато' );
	} else {
  	alert( 'Верно!' );
	}

// 13.02.2023	Тернарный оператор "?:"
Иногда нам нужно определить переменную в зависимости от условия.

Стандартный пример:
	let accessAllowed;
	let age = prompt('Сколько вам лет?', '');

	if (age > 18) {
  	accessAllowed = true;
	} else {
 	 accessAllowed = false;
	}

	alert(accessAllowed);

Так называемый «условный» оператор «вопросительный знак» позволяет нам сделать это более коротким и простым способом. Оператор представлен знаком вопроса ?. Его также называют «тернарный», так как этот оператор, единственный в своём роде, имеет три аргумента.

Пример с ипользованием тернарного оператора: result = условие ? значение1 : значение2;
	let accessAllowed = (age > 18) ? true : false;
		
В примере выше вы можете избежать использования оператора вопросительного знака ?, т.к. сравнение само по себе уже возвращает true/false: let accessAllowed = age > 18;

// 13.02.2023	Несколько операторов: "?"
Последовательность операторов вопросительного знака ? позволяет вернуть значение, которое зависит от более чем одного условия.
	let age = prompt('Возраст?', 18);

	let message = (age < 3) ? 'Здравствуй, малыш!' :
	(age < 18) ? 'Привет!' :
	(age < 100) ? 'Здравствуйте!' :
	'Какой необычный возраст!';

	alert( message );

Поначалу может быть сложно понять, что происходит. Но при ближайшем рассмотрении мы видим, что это обычная последовательная проверка:

Первый знак вопроса проверяет age < 3.
Если верно – возвращает 'Здравствуй, малыш!'. В противном случае, проверяет выражение после двоеточия „:“, вычисляет age < 18.
Если это верно – возвращает 'Привет!'. В противном случае, проверяет выражение после следующего двоеточия „:“, вычисляет age < 100.
Если это верно – возвращает 'Здравствуйте!'. В противном случае, возвращает выражение после последнего двоеточия – 'Какой необычный возраст!'.

Вот как это выглядит при использовании if..else:

	if (age < 3) {
	message = 'Здравствуй, малыш!';
	} else if (age < 18) {
	message = 'Привет!';
	} else if (age < 100) {
	message = 'Здравствуйте!';
	} else {
	message = 'Какой необычный возраст!';
	}

// 13.02.2023	Логические операторы https://learn.javascript.ru/logical-operators
В JavaScript есть четыре логических оператора: || (ИЛИ), && (И) и ! (НЕ), ?? (Оператор нулевого слияния).

// 13.02.2023	Цикл while
При написании скриптов зачастую встаёт задача сделать однотипное действие много раз.
	while (true) {
  	// код
  	// также называемый "телом цикла"
	}

Если boolean тип данных в условия While = True, то цикл выполнится.
Одно выполнение тела цикла по-научному называется итерация. Цикл в примере выше совершает три итерации.

Проверку условия можно разместить под телом цикла, используя специальный синтаксис do..while:
	do {
	// тело цикла
	} while (condition);

Цикл сначала выполнит тело, а затем проверит условие condition.

// 13.02.2023	Цикл for
	for (let i = 0; i < 3; i++) { // выведет 0, затем 1, затем 2
	alert(i);
	}

	Любая часть for может быть пропущена.
	for (;;) {
	// будет выполняться вечно
	}

// 13.02.2023	Прерывание цикла: «break»
Например, следующий код подсчитывает сумму вводимых чисел до тех пор, пока посетитель их вводит, а затем – выдаёт:
	let sum = 0;

	while (true) {
	let value = +prompt("Введите число", '');
	if (!value) break;
	sum += value;
	}
	alert( 'Сумма: ' + sum );

// 13.02.2023	Вообще, сочетание «бесконечный цикл + break» – отличная штука для тех ситуаций, когда условие, по которому нужно прерваться, находится не в начале или конце цикла, а посередине или даже в нескольких местах его тела.

// 13.02.2023	Переход к следующей итерации: continue
При её выполнении цикл не прерывается, а переходит к следующей итерации (если условие все ещё равно true).
	for (let i = 0; i < 10; i++) {
	// если true, пропустить оставшуюся часть тела цикла
	if (i % 2 == 0) continue;
	alert(i); // 1, затем 3, 5, 7, 9
	}

//14.02.2023	Циклы while и for
Цикл «while» - сначала проверяет верно ли значение и если да/true, то выполняет его.
	while (true) {
	// код
	// также называемый "телом цикла"
	}

Цикл «while»
	let i = 0;
	while (i < 3) { // выводит 0, затем 1, затем 2 - пока значение true.
	alert( i );
	i++;
	}

Цикл «do…while» - сначала выполняет код внутри тела, после проверяет его на значение true.
	do {
	// тело цикла
	} while (true);

Цикл «for» - удобный счетчик.
	for (начало; условие; шаг) {
	// ... тело цикла ...
	}

Еще один пример:
	for (let i = 0; i < 3; i++) { // выведет 0, затем 1, затем 2
	alert(i);
	}

Любая часть for может быть пропущена, например: for (;;) - главное оставлять знаки ";". В данном примере цикл будет выполняться бесконечно.

Прерывание цикла: «break»
Обычно цикл завершается при вычислении условия в false. Но мы можем выйти из цикла в любой момент с помощью специальной директивы break. Вообще, сочетание «бесконечный цикл + break» – отличная штука для тех ситуаций, когда условие, по которому нужно прерваться, находится не в начале или конце цикла, а посередине или даже в нескольких местах его тела.
	let sum = 0;

	while (true) {

  	let value = +prompt("Введите число", '');

  	if (!value) break; // (*)

 	 sum += value;

	}
	alert( 'Сумма: ' + sum );

Переход к следующей итерации: continue
При её выполнении цикл не прерывается, а переходит к следующей итерации (если условие все ещё равно true).
	for (let i = 0; i < 10; i++) {

  	// если true, пропустить оставшуюся часть тела цикла
  	if (i % 2 == 0) continue;

	alert(i); // 1, затем 3, 5, 7, 9
	}

Нельзя использовать break/continue справа от оператора "?:".
if (i > 5) {
  alert(i);
} else {
  continue;
}

(i > 5) ? alert(i) : continue; // continue здесь приведёт к ошибке.

//14.02.2023	Конструкция "switch"
Пример:
switch(x) {
  case 'value1':  // if (x === 'value1')
    ...
    break;

  case 'value2':  // if (x === 'value2')
    ...
    break;

  default:
    ...
    break;
}

Конструкция switch имеет один или более блок case и необязательный блок default.
Нужно отметить, что проверка на равенство всегда строгая. Значения должны быть одного типа, чтобы выполнялось равенство.

//15.02.2023	Функции
Чтобы не повторять один и тот же код во многих местах, придуманы функции. Функции являются основными «строительными блоками» программы.
Примеры встроенных функций вы уже видели – это alert(message), prompt(message, default) и confirm(question). Но можно создавать и свои.

Объявление функции
Для создания функций мы можем использовать объявление функции.
Пример объявления функции:
	function showMessage() {
	alert( 'Всем привет!' );
	}

Вначале идёт ключевое слово function, после него имя функции, затем список параметров в круглых скобках через запятую (в вышеприведённом примере он пустой) и, наконец, код функции, также называемый «телом функции», внутри фигурных скобок.
function showMessage() {
  alert( 'Всем привет!' );
}

showMessage();
showMessage();

Вызов showMessage() выполняет код функции. Здесь мы увидим сообщение дважды.
Этот пример явно демонстрирует одно из главных предназначений функций: избавление от дублирования кода.

Локальные переменные
Переменные, объявленные внутри функции, видны только внутри этой функции.
	function showMessage() {
	let message = "Привет, я JavaScript!"; // локальная переменная
	alert( message );
	}

	showMessage(); // Привет, я JavaScript!

	alert( message ); // <-- будет ошибка, т.к. переменная видна только внутри функции

Внешние переменные
У функции есть доступ к внешним переменным, например:
	let userName = 'Вася';

function showMessage() {
	let message = 'Привет, ' + userName;
	alert(message);
	}

	showMessage(); // Привет, Вася

Функция обладает полным доступом к внешним переменным и может изменять их значение.
Внешняя переменная используется, только если внутри функции нет такой локальной.
Если одноимённая переменная объявляется внутри функции, тогда она перекрывает внешнюю.
Переменные, объявленные снаружи всех функций, такие как внешняя переменная – называются глобальными.
Желательно сводить использование глобальных переменных к минимуму. В современном коде обычно мало или совсем нет глобальных переменных. Хотя они иногда полезны для хранения важнейших «общепроектовых» данных.

Параметры	
Мы можем передать внутрь функции любую информацию, используя параметры.
	function showMessage(from, text) { // параметры: from, text
	alert(from + ': ' + text);
	}
	showMessage('Аня', 'Привет!'); // Аня: Привет! (*)
	showMessage('Аня', "Как дела?"); // Аня: Как дела? (**)

	function showMessage(from, text) {
	from = '*' + from + '*'; // немного украсим "from"
	alert( from + ': ' + text );
	}
	let from = "Аня";
	showMessage(from, "Привет"); // *Аня*: Привет
	// значение "from" осталось прежним, функция изменила значение локальной переменной
	alert( from ); // Аня

Параметр – это переменная, указанная в круглых скобках в объявлении функции.
Аргумент – это значение, которое передаётся функции при её вызове.

Значения по умолчанию
Если при вызове функции аргумент не был указан, то его значением становится undefined.
Если мы хотим задать параметру text значение по умолчанию, мы должны указать его.
Пример: function showMessage(from, text = "ЗАГЛУШКА ДЛЯ НАШЕГО ПАРАМЕТРА").

Возврат значения
Функция может вернуть результат, который будет передан в вызвавший её код.
	function sum(a, b) {
	return a + b;
	}

	let result = sum(1, 2);
	alert( result ); // 3

Пример еще один:
	function checkAge(age) {
	if (age >= 18) {
		return true;
	} else {
		return confirm('А родители разрешили?');
	}
	}

	let age = prompt('Сколько вам лет?', 18);

	if ( checkAge(age) ) {
	alert( 'Доступ получен' );
	} else {
	alert( 'Доступ закрыт' );
	}


После функций нужно вернуться: 2.11 - 2.12 - 2.13.			
На каком этапе закончил обучение 
1) learn.javascript - https://learn.javascript.ru/while-for#continue .пункт 2.13
2) https://learn.javascript.ru/function-basics#vozvrat-znacheniya